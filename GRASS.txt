local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
RequestCommand:InvokeServer(";btools me")
RequestCommand:InvokeServer(";fogcolor black")
wait(0.4)
RequestCommand:InvokeServer(";punish all")
wait(0.1)
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end
local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function delete(part)
	local args = {
		[1] = "Remove",
		[2] = {
			[1] = part
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function deleteall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				delete(v)
			end)
		end
	end
end

deleteall()

-- 避免重复定义ReplicatedStorage和RequestCommand，已删除重复代码
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

-- 避免重复定义getf3x函数，已删除重复代码
local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function resize(part,size,cf)
	local args = {
		[1] = "SyncResize",
		[2] = {
			[1] = {
				["Part"] = part,
				["CFrame"] = cf,
				["Size"] = size
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmaterial(part,mate,trans)
	local args = {
		[1] = "SyncMaterial",
		[2] = {
			[1] = {
				["Part"] = part,
				["Material"] = mate
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function transparency(part,trans)
	local args = {
		[1] = "SyncMaterial",
		[2] = {
			[1] = {
				["Part"] = part,
				["Transparency"] = trans
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function color(part, color)
	local args = {
		[1] = "SyncColor",
		[2] = {
			[1] = {
				["Part"] = part,
				["Color"] = color,
				["UnionColoring"] = false
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshid(part, id)
	local args = {
		[1] = "SyncMesh",
		[2] = {
			[1] = {
				["Part"] = part,
				["MeshId"] = "rbxassetid://"..id
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function makemesh(part)
	local args = {
		[1] = "CreateMeshes",
		[2] = {
			[1] = {
				["Part"] = part
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshsize(part, vectora)
	local args = {
		[1] = "SyncMesh",
		[2] = {
			[1] = {
				["Part"] = part,
				["Scale"] = vectora
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshtexture(part, id)
	local args = {
		[1] = "SyncMesh",
		[2] = {
			[1] = {
				["Part"] = part,
				["TextureId"] =	"rbxassetid://"..id
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function name(part, stringa)
	local args = {
		[1] = "SetName",
		[2] = {
			[1] = part
		},
		[3] = stringa
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function lock(part, boolean)
	local args = {
		[1] = "SetLocked",
		[2] = {
			[1] = part
		},
		[3] = boolean
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function setcollision(part, booleana)
	local args = {
		[1] = "SyncCollision",
		[2] = {
			[1] = {
				["Part"] = part,
				["CanCollide"] = booleana
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function setanchor(part, boolean)
	local args = {
		[1] = "SyncAnchor",
		[2] = {
			[1] = {
				["Part"] = part,
				["Anchored"] = boolean
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function createdecal(part, side)
	local args = {
		[1] = "CreateTextures",
		[2] = {
			[1] = {
				["Part"] = part,
				["Face"] = side,
				["TextureType"] = "Decal"
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function setdecal(part, asset, side)
	local args = {
		[1] = "SyncTexture",
		[2] = {
			[1] = {
				["Part"] = part,
				["Face"] = side,
				["TextureType"] = "Decal",
				["Texture"] = "rbxassetid://".. asset
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function makerealmbase()
	local position = CFrame.new(0, 5, 0)
	local base = serverendpoint:InvokeServer("CreatePart", "Normal", position, workspace)
	resize(base, Vector3.new(200, 16, 200), position)
	syncmaterial(base, Enum.Material.Grass)
	color(base, Color3.new(0, 0.364706, 0.0235294))
	name(base, "BasePlate")
	lock(base, true)

	local spawnpos = CFrame.new(34.5, 8.1, -26)
	local spawna = serverendpoint:InvokeServer("CreatePart", "Spawn", spawnpos, workspace)
	resize(spawna, Vector3.new(0.01, 0.01, 0.01), spawnpos)
	name(spawna, "SpawnLocation")
	lock(spawna, true)

	createdecal(spawna, Enum.NormalId.Top)
	setdecal(spawna, "0", Enum.NormalId.Top) -- ganti decalnya pake decal lu
	transparency(spawna, 1)
	

	local pos = CFrame.new(74.143, 24, -25.232)
	local rules = serverendpoint:InvokeServer("CreatePart", "Normal", pos, workspace)
	transparency(rules, 1)
	setcollision(rules, false)
	createdecal(rules, Enum.NormalId.Left)
	setdecal(rules, "0", Enum.NormalId.Left)
	color(rules, Color3.new(1, 1, 1))
	resize(rules, Vector3.new(4, 23, 37), pos)

	local pos = CFrame.new(1.143, 24, -25.232)
	local bad = serverendpoint:InvokeServer("CreatePart", "Normal", pos, workspace)
	transparency(bad, 1)
	setcollision(bad, false)
	createdecal(bad, Enum.NormalId.Right)
	setdecal(bad, "0", Enum.NormalId.Right)
	resize(bad, Vector3.new(4, 23, 37), pos)
end

local function sky()
	local position = CFrame.new(0, -20, 0)
	local sky = serverendpoint:InvokeServer("CreatePart", "Normal", position, workspace)
	makemesh(sky)
	syncmeshid(sky, "111891702759441")
	syncmeshtexture(sky, "95228274364487")
	syncmeshsize(sky, Vector3.new(0.01, 0.01, 0.01))
	lock(sky, true)
	name(sky, "Part")
	setcollision(sky, false)
end

local function unanchorall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				setanchor(v, false)
			end)
		end
	end
end

local function realm()
	sky()
	makerealmbase()
end

realm()

RequestCommand:InvokeServer(";res all")
wait(0.5)
RequestCommand:InvokeServer(";r6 all")
RequestCommand:InvokeServer(";time 12")
wait(0.9)
RequestCommand:InvokeServer(";savemap")
